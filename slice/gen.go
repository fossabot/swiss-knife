// +build ignore

// This program generate contributors.go
package main

import (
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

var types = []string{
	"bool",
	"byte",
	"complex128",
	"complex64",
	"error",
	"float32",
	"float64",
	"int",
	"int16",
	"int32",
	"int64",
	"int8",
	"rune",
	"string",
	"uint",
	"uint16",
	"uint32",
	"uint64",
	"uint8",
	"uintptr",
}

var files = map[string]*template.Template{
	"slices":      codeTemplate,
	"slices_test": codeTestTemplate,
}

func main() {
	for file, template := range files {
		generateCode(file, template)
	}
}

func generateCode(fileName string, tpl *template.Template) {
	f, err := os.Create(fileName + ".go")
	die(err)
	defer f.Close()

	tpl.Execute(f, struct {
		Timestamp time.Time
		Types     []string
	}{
		Timestamp: time.Now(),
		Types:     types,
	})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var templateFuncs = template.FuncMap{
	"Title": strings.Title,
}

var codeTestTemplate = template.Must(template.New("").Funcs(templateFuncs).Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
package slice

import (
	"reflect"
	"testing"
)
{{ range .Types }}
func Test{{ Title . }}ForEach(t *testing.T) {
	inputInterface := getInput({{ printf "%q" . }})
	input := inputInterface.([]{{ . }})

	expectInterface := getExpect({{ printf "%q" . }})
	expect := expectInterface.([]{{ . }})

	current := make([]{{ . }}, len(expect))

	if err := {{ Title . }}ForEach(input, func(e {{ . }}, i int) {
		current[i] = {{ . }}Function(e)
	}); err != nil {
		t.Errorf("running {{ Title . }}ForEach got the error: %s",  err.Error())
	}

	if got := reflect.DeepEqual(current, expect); !got {
		t.Errorf("{{ Title . }}ForEach returns %v; expected %v", current, expect)
	}
}
{{ end }}
`))

var codeTemplate = template.Must(template.New("").Funcs(templateFuncs).Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
package slice

import "fmt"

{{ range .Types }}
// {{ Title . }}
func {{ Title . }}ForEach(input []{{ . }}, function interface{}) error {
	if !(isFunc(function)) {
		e := fmt.Sprintf("parameter (%s) is not a function", function)
		return newError(e)
	}

	switch function.(type) {
	case func({{ . }}):
		fn := function.(func({{ . }}))
		for _, element := range input {
			fn(element)
		}

	case func({{ . }}, int):
		fn := function.(func({{ . }}, int))
		for i, element := range input {
			fn(element, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func({{ . }})", "func({{ . }}, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}
{{ end }}
`))
