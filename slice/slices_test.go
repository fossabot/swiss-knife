// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// 2019-05-17 14:20:44.018279124 -0500 CDT m=+0.003288075
package slice

import (
	"reflect"
	"testing"
)

func TestForEach(t *testing.T) {
	t.Run("Testing ForEach", func(t *testing.T) {

		t.Run("Testing boolForEach", func(t *testing.T) {
			inputInterface := getInput("bool")
			input := inputInterface.([]bool)

			expectInterface := getExpect("bool")
			expect := expectInterface.([]bool)

			current := make([]bool, len(expect))

			t.Logf("Testing boolForEach(%v, func(e bool, i int))", input)
			if err := boolForEach(input, func(e bool, i int) {
				current[i] = boolFunction(e)
			}); err != nil {
				t.Errorf("running boolForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("boolForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing complex128ForEach", func(t *testing.T) {
			inputInterface := getInput("complex128")
			input := inputInterface.([]complex128)

			expectInterface := getExpect("complex128")
			expect := expectInterface.([]complex128)

			current := make([]complex128, len(expect))

			t.Logf("Testing complex128ForEach(%v, func(e complex128, i int))", input)
			if err := complex128ForEach(input, func(e complex128, i int) {
				current[i] = complex128Function(e)
			}); err != nil {
				t.Errorf("running complex128ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("complex128ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing complex64ForEach", func(t *testing.T) {
			inputInterface := getInput("complex64")
			input := inputInterface.([]complex64)

			expectInterface := getExpect("complex64")
			expect := expectInterface.([]complex64)

			current := make([]complex64, len(expect))

			t.Logf("Testing complex64ForEach(%v, func(e complex64, i int))", input)
			if err := complex64ForEach(input, func(e complex64, i int) {
				current[i] = complex64Function(e)
			}); err != nil {
				t.Errorf("running complex64ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("complex64ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing errorForEach", func(t *testing.T) {
			inputInterface := getInput("error")
			input := inputInterface.([]error)

			expectInterface := getExpect("error")
			expect := expectInterface.([]error)

			current := make([]error, len(expect))

			t.Logf("Testing errorForEach(%v, func(e error, i int))", input)
			if err := errorForEach(input, func(e error, i int) {
				current[i] = errorFunction(e)
			}); err != nil {
				t.Errorf("running errorForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("errorForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing float32ForEach", func(t *testing.T) {
			inputInterface := getInput("float32")
			input := inputInterface.([]float32)

			expectInterface := getExpect("float32")
			expect := expectInterface.([]float32)

			current := make([]float32, len(expect))

			t.Logf("Testing float32ForEach(%v, func(e float32, i int))", input)
			if err := float32ForEach(input, func(e float32, i int) {
				current[i] = float32Function(e)
			}); err != nil {
				t.Errorf("running float32ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("float32ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing float64ForEach", func(t *testing.T) {
			inputInterface := getInput("float64")
			input := inputInterface.([]float64)

			expectInterface := getExpect("float64")
			expect := expectInterface.([]float64)

			current := make([]float64, len(expect))

			t.Logf("Testing float64ForEach(%v, func(e float64, i int))", input)
			if err := float64ForEach(input, func(e float64, i int) {
				current[i] = float64Function(e)
			}); err != nil {
				t.Errorf("running float64ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("float64ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing intForEach", func(t *testing.T) {
			inputInterface := getInput("int")
			input := inputInterface.([]int)

			expectInterface := getExpect("int")
			expect := expectInterface.([]int)

			current := make([]int, len(expect))

			t.Logf("Testing intForEach(%v, func(e int, i int))", input)
			if err := intForEach(input, func(e int, i int) {
				current[i] = intFunction(e)
			}); err != nil {
				t.Errorf("running intForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("intForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing int16ForEach", func(t *testing.T) {
			inputInterface := getInput("int16")
			input := inputInterface.([]int16)

			expectInterface := getExpect("int16")
			expect := expectInterface.([]int16)

			current := make([]int16, len(expect))

			t.Logf("Testing int16ForEach(%v, func(e int16, i int))", input)
			if err := int16ForEach(input, func(e int16, i int) {
				current[i] = int16Function(e)
			}); err != nil {
				t.Errorf("running int16ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("int16ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing int32ForEach", func(t *testing.T) {
			inputInterface := getInput("int32")
			input := inputInterface.([]int32)

			expectInterface := getExpect("int32")
			expect := expectInterface.([]int32)

			current := make([]int32, len(expect))

			t.Logf("Testing int32ForEach(%v, func(e int32, i int))", input)
			if err := int32ForEach(input, func(e int32, i int) {
				current[i] = int32Function(e)
			}); err != nil {
				t.Errorf("running int32ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("int32ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing int64ForEach", func(t *testing.T) {
			inputInterface := getInput("int64")
			input := inputInterface.([]int64)

			expectInterface := getExpect("int64")
			expect := expectInterface.([]int64)

			current := make([]int64, len(expect))

			t.Logf("Testing int64ForEach(%v, func(e int64, i int))", input)
			if err := int64ForEach(input, func(e int64, i int) {
				current[i] = int64Function(e)
			}); err != nil {
				t.Errorf("running int64ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("int64ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing int8ForEach", func(t *testing.T) {
			inputInterface := getInput("int8")
			input := inputInterface.([]int8)

			expectInterface := getExpect("int8")
			expect := expectInterface.([]int8)

			current := make([]int8, len(expect))

			t.Logf("Testing int8ForEach(%v, func(e int8, i int))", input)
			if err := int8ForEach(input, func(e int8, i int) {
				current[i] = int8Function(e)
			}); err != nil {
				t.Errorf("running int8ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("int8ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing stringForEach", func(t *testing.T) {
			inputInterface := getInput("string")
			input := inputInterface.([]string)

			expectInterface := getExpect("string")
			expect := expectInterface.([]string)

			current := make([]string, len(expect))

			t.Logf("Testing stringForEach(%v, func(e string, i int))", input)
			if err := stringForEach(input, func(e string, i int) {
				current[i] = stringFunction(e)
			}); err != nil {
				t.Errorf("running stringForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("stringForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing uintForEach", func(t *testing.T) {
			inputInterface := getInput("uint")
			input := inputInterface.([]uint)

			expectInterface := getExpect("uint")
			expect := expectInterface.([]uint)

			current := make([]uint, len(expect))

			t.Logf("Testing uintForEach(%v, func(e uint, i int))", input)
			if err := uintForEach(input, func(e uint, i int) {
				current[i] = uintFunction(e)
			}); err != nil {
				t.Errorf("running uintForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("uintForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing uint16ForEach", func(t *testing.T) {
			inputInterface := getInput("uint16")
			input := inputInterface.([]uint16)

			expectInterface := getExpect("uint16")
			expect := expectInterface.([]uint16)

			current := make([]uint16, len(expect))

			t.Logf("Testing uint16ForEach(%v, func(e uint16, i int))", input)
			if err := uint16ForEach(input, func(e uint16, i int) {
				current[i] = uint16Function(e)
			}); err != nil {
				t.Errorf("running uint16ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("uint16ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing uint32ForEach", func(t *testing.T) {
			inputInterface := getInput("uint32")
			input := inputInterface.([]uint32)

			expectInterface := getExpect("uint32")
			expect := expectInterface.([]uint32)

			current := make([]uint32, len(expect))

			t.Logf("Testing uint32ForEach(%v, func(e uint32, i int))", input)
			if err := uint32ForEach(input, func(e uint32, i int) {
				current[i] = uint32Function(e)
			}); err != nil {
				t.Errorf("running uint32ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("uint32ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing uint64ForEach", func(t *testing.T) {
			inputInterface := getInput("uint64")
			input := inputInterface.([]uint64)

			expectInterface := getExpect("uint64")
			expect := expectInterface.([]uint64)

			current := make([]uint64, len(expect))

			t.Logf("Testing uint64ForEach(%v, func(e uint64, i int))", input)
			if err := uint64ForEach(input, func(e uint64, i int) {
				current[i] = uint64Function(e)
			}); err != nil {
				t.Errorf("running uint64ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("uint64ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing uint8ForEach", func(t *testing.T) {
			inputInterface := getInput("uint8")
			input := inputInterface.([]uint8)

			expectInterface := getExpect("uint8")
			expect := expectInterface.([]uint8)

			current := make([]uint8, len(expect))

			t.Logf("Testing uint8ForEach(%v, func(e uint8, i int))", input)
			if err := uint8ForEach(input, func(e uint8, i int) {
				current[i] = uint8Function(e)
			}); err != nil {
				t.Errorf("running uint8ForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("uint8ForEach returns %v; expected %v", current, expect)
			}
		})

		t.Run("Testing uintptrForEach", func(t *testing.T) {
			inputInterface := getInput("uintptr")
			input := inputInterface.([]uintptr)

			expectInterface := getExpect("uintptr")
			expect := expectInterface.([]uintptr)

			current := make([]uintptr, len(expect))

			t.Logf("Testing uintptrForEach(%v, func(e uintptr, i int))", input)
			if err := uintptrForEach(input, func(e uintptr, i int) {
				current[i] = uintptrFunction(e)
			}); err != nil {
				t.Errorf("running uintptrForEach got the error: %s", err.Error())
			}

			if got := reflect.DeepEqual(current, expect); !got {
				t.Errorf("uintptrForEach returns %v; expected %v", current, expect)
			}
		})

	})
}

func TestIncludes(t *testing.T) {
	t.Run("Testing Includes", func(t *testing.T) {

		t.Run("Testing boolIncludes", func(t *testing.T) {
			input := getInput("bool")

			elements := input.([]bool)
			expect := true

			// Testing without third parameter
			t.Logf("Testing boolIncludes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing boolIncludes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing boolIncludes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing boolIncludes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing boolIncludes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing complex128Includes", func(t *testing.T) {
			input := getInput("complex128")

			elements := input.([]complex128)
			expect := true

			// Testing without third parameter
			t.Logf("Testing complex128Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing complex128Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing complex128Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing complex128Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing complex128Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing complex64Includes", func(t *testing.T) {
			input := getInput("complex64")

			elements := input.([]complex64)
			expect := true

			// Testing without third parameter
			t.Logf("Testing complex64Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing complex64Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing complex64Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing complex64Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing complex64Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing errorIncludes", func(t *testing.T) {
			input := getInput("error")

			elements := input.([]error)
			expect := true

			// Testing without third parameter
			t.Logf("Testing errorIncludes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing errorIncludes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing errorIncludes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing errorIncludes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing errorIncludes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing float32Includes", func(t *testing.T) {
			input := getInput("float32")

			elements := input.([]float32)
			expect := true

			// Testing without third parameter
			t.Logf("Testing float32Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing float32Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing float32Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing float32Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing float32Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing float64Includes", func(t *testing.T) {
			input := getInput("float64")

			elements := input.([]float64)
			expect := true

			// Testing without third parameter
			t.Logf("Testing float64Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing float64Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing float64Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing float64Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing float64Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing intIncludes", func(t *testing.T) {
			input := getInput("int")

			elements := input.([]int)
			expect := true

			// Testing without third parameter
			t.Logf("Testing intIncludes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing intIncludes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing intIncludes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing intIncludes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing intIncludes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing int16Includes", func(t *testing.T) {
			input := getInput("int16")

			elements := input.([]int16)
			expect := true

			// Testing without third parameter
			t.Logf("Testing int16Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing int16Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing int16Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing int16Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing int16Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing int32Includes", func(t *testing.T) {
			input := getInput("int32")

			elements := input.([]int32)
			expect := true

			// Testing without third parameter
			t.Logf("Testing int32Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing int32Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing int32Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing int32Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing int32Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing int64Includes", func(t *testing.T) {
			input := getInput("int64")

			elements := input.([]int64)
			expect := true

			// Testing without third parameter
			t.Logf("Testing int64Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing int64Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing int64Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing int64Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing int64Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing int8Includes", func(t *testing.T) {
			input := getInput("int8")

			elements := input.([]int8)
			expect := true

			// Testing without third parameter
			t.Logf("Testing int8Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing int8Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing int8Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing int8Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing int8Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing stringIncludes", func(t *testing.T) {
			input := getInput("string")

			elements := input.([]string)
			expect := true

			// Testing without third parameter
			t.Logf("Testing stringIncludes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing stringIncludes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing stringIncludes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing stringIncludes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing stringIncludes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing uintIncludes", func(t *testing.T) {
			input := getInput("uint")

			elements := input.([]uint)
			expect := true

			// Testing without third parameter
			t.Logf("Testing uintIncludes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing uintIncludes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing uintIncludes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing uintIncludes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing uintIncludes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing uint16Includes", func(t *testing.T) {
			input := getInput("uint16")

			elements := input.([]uint16)
			expect := true

			// Testing without third parameter
			t.Logf("Testing uint16Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing uint16Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing uint16Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing uint16Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing uint16Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing uint32Includes", func(t *testing.T) {
			input := getInput("uint32")

			elements := input.([]uint32)
			expect := true

			// Testing without third parameter
			t.Logf("Testing uint32Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing uint32Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing uint32Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing uint32Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing uint32Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing uint64Includes", func(t *testing.T) {
			input := getInput("uint64")

			elements := input.([]uint64)
			expect := true

			// Testing without third parameter
			t.Logf("Testing uint64Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing uint64Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing uint64Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing uint64Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing uint64Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing uint8Includes", func(t *testing.T) {
			input := getInput("uint8")

			elements := input.([]uint8)
			expect := true

			// Testing without third parameter
			t.Logf("Testing uint8Includes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing uint8Includes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing uint8Includes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing uint8Includes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing uint8Includes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

		t.Run("Testing uintptrIncludes", func(t *testing.T) {
			input := getInput("uintptr")

			elements := input.([]uintptr)
			expect := true

			// Testing without third parameter
			t.Logf("Testing uintptrIncludes(%v, %v)", input, elements[0])
			got, err := Includes(input, elements[0])
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but out the range of the
			// elements of input, expected true
			t.Logf("Testing uintptrIncludes(%v, %v, %d)", input, elements[0], -10)
			got, err = Includes(input, elements[0], -10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third negative parameter but in the range of the
			// elements of input, expected false
			expect = false

			t.Logf("Testing uintptrIncludes(%v, %v, %d)", input, elements[0], -1)
			got, err = Includes(input, elements[0], -1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but in the range of the
			// elements of input, expected false
			t.Logf("Testing uintptrIncludes(%v, %v, %d)", input, elements[0], 1)
			got, err = Includes(input, elements[0], 1)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}

			// Testing with third positive parameter but out the range of the
			// elements of input, expected false
			t.Logf("Testing uintptrIncludes(%v, %v, %d)", input, elements[0], 10)
			got, err = Includes(input, elements[0], 10)
			if err != nil {
				t.Errorf("running Includes got the error: %s", err.Error())
			}

			if got != expect {
				t.Errorf("Includes returns %v; expected %v", got, expect)
			}
		})

	})
}

func TestMap(t *testing.T) {
	t.Run("Testing Map", func(t *testing.T) {

		t.Run("Testing boolMap", func(t *testing.T) {
			inputInterface := getInput("bool")
			input := inputInterface.([]bool)

			expect := input

			t.Logf("Testing boolMap(%v, func(e bool, i int)) interface{}", input)
			current, err := boolMap(input, func(e bool, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running boolMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("boolMap returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing boolMap(%v, func(e bool) interface{}", input)
			current, err = boolMap(input, func(e bool) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running boolMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("boolMap returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing complex128Map", func(t *testing.T) {
			inputInterface := getInput("complex128")
			input := inputInterface.([]complex128)

			expect := input

			t.Logf("Testing complex128Map(%v, func(e complex128, i int)) interface{}", input)
			current, err := complex128Map(input, func(e complex128, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running complex128Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("complex128Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing complex128Map(%v, func(e complex128) interface{}", input)
			current, err = complex128Map(input, func(e complex128) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running complex128Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("complex128Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing complex64Map", func(t *testing.T) {
			inputInterface := getInput("complex64")
			input := inputInterface.([]complex64)

			expect := input

			t.Logf("Testing complex64Map(%v, func(e complex64, i int)) interface{}", input)
			current, err := complex64Map(input, func(e complex64, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running complex64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("complex64Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing complex64Map(%v, func(e complex64) interface{}", input)
			current, err = complex64Map(input, func(e complex64) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running complex64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("complex64Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing errorMap", func(t *testing.T) {
			inputInterface := getInput("error")
			input := inputInterface.([]error)

			expect := input

			t.Logf("Testing errorMap(%v, func(e error, i int)) interface{}", input)
			current, err := errorMap(input, func(e error, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running errorMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("errorMap returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing errorMap(%v, func(e error) interface{}", input)
			current, err = errorMap(input, func(e error) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running errorMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("errorMap returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing float32Map", func(t *testing.T) {
			inputInterface := getInput("float32")
			input := inputInterface.([]float32)

			expect := input

			t.Logf("Testing float32Map(%v, func(e float32, i int)) interface{}", input)
			current, err := float32Map(input, func(e float32, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running float32Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("float32Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing float32Map(%v, func(e float32) interface{}", input)
			current, err = float32Map(input, func(e float32) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running float32Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("float32Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing float64Map", func(t *testing.T) {
			inputInterface := getInput("float64")
			input := inputInterface.([]float64)

			expect := input

			t.Logf("Testing float64Map(%v, func(e float64, i int)) interface{}", input)
			current, err := float64Map(input, func(e float64, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running float64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("float64Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing float64Map(%v, func(e float64) interface{}", input)
			current, err = float64Map(input, func(e float64) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running float64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("float64Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing intMap", func(t *testing.T) {
			inputInterface := getInput("int")
			input := inputInterface.([]int)

			expect := input

			t.Logf("Testing intMap(%v, func(e int, i int)) interface{}", input)
			current, err := intMap(input, func(e int, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running intMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("intMap returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing intMap(%v, func(e int) interface{}", input)
			current, err = intMap(input, func(e int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running intMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("intMap returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing int16Map", func(t *testing.T) {
			inputInterface := getInput("int16")
			input := inputInterface.([]int16)

			expect := input

			t.Logf("Testing int16Map(%v, func(e int16, i int)) interface{}", input)
			current, err := int16Map(input, func(e int16, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int16Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int16Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing int16Map(%v, func(e int16) interface{}", input)
			current, err = int16Map(input, func(e int16) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int16Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int16Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing int32Map", func(t *testing.T) {
			inputInterface := getInput("int32")
			input := inputInterface.([]int32)

			expect := input

			t.Logf("Testing int32Map(%v, func(e int32, i int)) interface{}", input)
			current, err := int32Map(input, func(e int32, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int32Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int32Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing int32Map(%v, func(e int32) interface{}", input)
			current, err = int32Map(input, func(e int32) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int32Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int32Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing int64Map", func(t *testing.T) {
			inputInterface := getInput("int64")
			input := inputInterface.([]int64)

			expect := input

			t.Logf("Testing int64Map(%v, func(e int64, i int)) interface{}", input)
			current, err := int64Map(input, func(e int64, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int64Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing int64Map(%v, func(e int64) interface{}", input)
			current, err = int64Map(input, func(e int64) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int64Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing int8Map", func(t *testing.T) {
			inputInterface := getInput("int8")
			input := inputInterface.([]int8)

			expect := input

			t.Logf("Testing int8Map(%v, func(e int8, i int)) interface{}", input)
			current, err := int8Map(input, func(e int8, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int8Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int8Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing int8Map(%v, func(e int8) interface{}", input)
			current, err = int8Map(input, func(e int8) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running int8Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("int8Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing stringMap", func(t *testing.T) {
			inputInterface := getInput("string")
			input := inputInterface.([]string)

			expect := input

			t.Logf("Testing stringMap(%v, func(e string, i int)) interface{}", input)
			current, err := stringMap(input, func(e string, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running stringMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("stringMap returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing stringMap(%v, func(e string) interface{}", input)
			current, err = stringMap(input, func(e string) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running stringMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("stringMap returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing uintMap", func(t *testing.T) {
			inputInterface := getInput("uint")
			input := inputInterface.([]uint)

			expect := input

			t.Logf("Testing uintMap(%v, func(e uint, i int)) interface{}", input)
			current, err := uintMap(input, func(e uint, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uintMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uintMap returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing uintMap(%v, func(e uint) interface{}", input)
			current, err = uintMap(input, func(e uint) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uintMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uintMap returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing uint16Map", func(t *testing.T) {
			inputInterface := getInput("uint16")
			input := inputInterface.([]uint16)

			expect := input

			t.Logf("Testing uint16Map(%v, func(e uint16, i int)) interface{}", input)
			current, err := uint16Map(input, func(e uint16, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint16Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint16Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing uint16Map(%v, func(e uint16) interface{}", input)
			current, err = uint16Map(input, func(e uint16) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint16Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint16Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing uint32Map", func(t *testing.T) {
			inputInterface := getInput("uint32")
			input := inputInterface.([]uint32)

			expect := input

			t.Logf("Testing uint32Map(%v, func(e uint32, i int)) interface{}", input)
			current, err := uint32Map(input, func(e uint32, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint32Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint32Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing uint32Map(%v, func(e uint32) interface{}", input)
			current, err = uint32Map(input, func(e uint32) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint32Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint32Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing uint64Map", func(t *testing.T) {
			inputInterface := getInput("uint64")
			input := inputInterface.([]uint64)

			expect := input

			t.Logf("Testing uint64Map(%v, func(e uint64, i int)) interface{}", input)
			current, err := uint64Map(input, func(e uint64, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint64Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing uint64Map(%v, func(e uint64) interface{}", input)
			current, err = uint64Map(input, func(e uint64) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint64Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint64Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing uint8Map", func(t *testing.T) {
			inputInterface := getInput("uint8")
			input := inputInterface.([]uint8)

			expect := input

			t.Logf("Testing uint8Map(%v, func(e uint8, i int)) interface{}", input)
			current, err := uint8Map(input, func(e uint8, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint8Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint8Map returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing uint8Map(%v, func(e uint8) interface{}", input)
			current, err = uint8Map(input, func(e uint8) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uint8Map got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uint8Map returns %v; expected %v", current[i], expect[i])
				}
			}

		})

		t.Run("Testing uintptrMap", func(t *testing.T) {
			inputInterface := getInput("uintptr")
			input := inputInterface.([]uintptr)

			expect := input

			t.Logf("Testing uintptrMap(%v, func(e uintptr, i int)) interface{}", input)
			current, err := uintptrMap(input, func(e uintptr, i int) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uintptrMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uintptrMap returns %v; expected %v", current[i], expect[i])
				}
			}

			t.Logf("Testing uintptrMap(%v, func(e uintptr) interface{}", input)
			current, err = uintptrMap(input, func(e uintptr) interface{} {
				return e
			})
			if err != nil {
				t.Errorf("running uintptrMap got the error: %s", err.Error())
			}

			for i, e := range expect {
				if got := reflect.DeepEqual(e, input[i]); !got {
					t.Errorf("uintptrMap returns %v; expected %v", current[i], expect[i])
				}
			}

		})

	})
}
