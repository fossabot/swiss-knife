// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// 2019-05-17 14:20:44.015538815 -0500 CDT m=+0.000547769
package slice

import "fmt"

func ForEach(inputInterface interface{}, function interface{}) error {
	switch input := inputInterface.(type) {

	case []bool:
		return boolForEach(input, function)

	case []complex128:
		return complex128ForEach(input, function)

	case []complex64:
		return complex64ForEach(input, function)

	case []error:
		return errorForEach(input, function)

	case []float32:
		return float32ForEach(input, function)

	case []float64:
		return float64ForEach(input, function)

	case []int:
		return intForEach(input, function)

	case []int16:
		return int16ForEach(input, function)

	case []int32:
		return int32ForEach(input, function)

	case []int64:
		return int64ForEach(input, function)

	case []int8:
		return int8ForEach(input, function)

	case []string:
		return stringForEach(input, function)

	case []uint:
		return uintForEach(input, function)

	case []uint16:
		return uint16ForEach(input, function)

	case []uint32:
		return uint32ForEach(input, function)

	case []uint64:
		return uint64ForEach(input, function)

	case []uint8:
		return uint8ForEach(input, function)

	case []uintptr:
		return uintptrForEach(input, function)

	}

	return nil
}

func Includes(inputInterface interface{}, eInterface interface{}, indexes ...int) (bool, error) {
	switch e := eInterface.(type) {

	case bool:
		input, ok := inputInterface.([]bool)
		if !ok {
			e := fmt.Sprintf("%s must be from bool", inputInterface)
			return false, newError(e)
		}
		return boolIncludes(input, e, indexes...), nil

	case complex128:
		input, ok := inputInterface.([]complex128)
		if !ok {
			e := fmt.Sprintf("%s must be from complex128", inputInterface)
			return false, newError(e)
		}
		return complex128Includes(input, e, indexes...), nil

	case complex64:
		input, ok := inputInterface.([]complex64)
		if !ok {
			e := fmt.Sprintf("%s must be from complex64", inputInterface)
			return false, newError(e)
		}
		return complex64Includes(input, e, indexes...), nil

	case error:
		input, ok := inputInterface.([]error)
		if !ok {
			e := fmt.Sprintf("%s must be from error", inputInterface)
			return false, newError(e)
		}
		return errorIncludes(input, e, indexes...), nil

	case float32:
		input, ok := inputInterface.([]float32)
		if !ok {
			e := fmt.Sprintf("%s must be from float32", inputInterface)
			return false, newError(e)
		}
		return float32Includes(input, e, indexes...), nil

	case float64:
		input, ok := inputInterface.([]float64)
		if !ok {
			e := fmt.Sprintf("%s must be from float64", inputInterface)
			return false, newError(e)
		}
		return float64Includes(input, e, indexes...), nil

	case int:
		input, ok := inputInterface.([]int)
		if !ok {
			e := fmt.Sprintf("%s must be from int", inputInterface)
			return false, newError(e)
		}
		return intIncludes(input, e, indexes...), nil

	case int16:
		input, ok := inputInterface.([]int16)
		if !ok {
			e := fmt.Sprintf("%s must be from int16", inputInterface)
			return false, newError(e)
		}
		return int16Includes(input, e, indexes...), nil

	case int32:
		input, ok := inputInterface.([]int32)
		if !ok {
			e := fmt.Sprintf("%s must be from int32", inputInterface)
			return false, newError(e)
		}
		return int32Includes(input, e, indexes...), nil

	case int64:
		input, ok := inputInterface.([]int64)
		if !ok {
			e := fmt.Sprintf("%s must be from int64", inputInterface)
			return false, newError(e)
		}
		return int64Includes(input, e, indexes...), nil

	case int8:
		input, ok := inputInterface.([]int8)
		if !ok {
			e := fmt.Sprintf("%s must be from int8", inputInterface)
			return false, newError(e)
		}
		return int8Includes(input, e, indexes...), nil

	case string:
		input, ok := inputInterface.([]string)
		if !ok {
			e := fmt.Sprintf("%s must be from string", inputInterface)
			return false, newError(e)
		}
		return stringIncludes(input, e, indexes...), nil

	case uint:
		input, ok := inputInterface.([]uint)
		if !ok {
			e := fmt.Sprintf("%s must be from uint", inputInterface)
			return false, newError(e)
		}
		return uintIncludes(input, e, indexes...), nil

	case uint16:
		input, ok := inputInterface.([]uint16)
		if !ok {
			e := fmt.Sprintf("%s must be from uint16", inputInterface)
			return false, newError(e)
		}
		return uint16Includes(input, e, indexes...), nil

	case uint32:
		input, ok := inputInterface.([]uint32)
		if !ok {
			e := fmt.Sprintf("%s must be from uint32", inputInterface)
			return false, newError(e)
		}
		return uint32Includes(input, e, indexes...), nil

	case uint64:
		input, ok := inputInterface.([]uint64)
		if !ok {
			e := fmt.Sprintf("%s must be from uint64", inputInterface)
			return false, newError(e)
		}
		return uint64Includes(input, e, indexes...), nil

	case uint8:
		input, ok := inputInterface.([]uint8)
		if !ok {
			e := fmt.Sprintf("%s must be from uint8", inputInterface)
			return false, newError(e)
		}
		return uint8Includes(input, e, indexes...), nil

	case uintptr:
		input, ok := inputInterface.([]uintptr)
		if !ok {
			e := fmt.Sprintf("%s must be from uintptr", inputInterface)
			return false, newError(e)
		}
		return uintptrIncludes(input, e, indexes...), nil

	}

	return false, nil
}

func Map(inputInterface interface{}, function interface{}) ([]interface{}, error) {
	switch input := inputInterface.(type) {

	case []bool:
		return boolMap(input, function)

	case []complex128:
		return complex128Map(input, function)

	case []complex64:
		return complex64Map(input, function)

	case []error:
		return errorMap(input, function)

	case []float32:
		return float32Map(input, function)

	case []float64:
		return float64Map(input, function)

	case []int:
		return intMap(input, function)

	case []int16:
		return int16Map(input, function)

	case []int32:
		return int32Map(input, function)

	case []int64:
		return int64Map(input, function)

	case []int8:
		return int8Map(input, function)

	case []string:
		return stringMap(input, function)

	case []uint:
		return uintMap(input, function)

	case []uint16:
		return uint16Map(input, function)

	case []uint32:
		return uint32Map(input, function)

	case []uint64:
		return uint64Map(input, function)

	case []uint8:
		return uint8Map(input, function)

	case []uintptr:
		return uintptrMap(input, function)

	}

	return nil, nil
}

// bool
func boolForEach(input []bool, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(bool):
		for _, e := range input {
			fn(e)
		}

	case func(bool, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(bool)", "func(bool, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func boolIncludes(input []bool, e bool, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func BoolMap(input []bool, function interface{}) ([]bool, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(bool) bool:
		r := make([]bool, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(bool, int) bool:
		r := make([]bool, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(bool) bool", "func(bool, int) bool", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func boolMap(input []bool, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(bool) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(bool, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(bool) bool:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(bool, int) bool:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(bool) interface{}", "func(bool, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// complex128
func complex128ForEach(input []complex128, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(complex128):
		for _, e := range input {
			fn(e)
		}

	case func(complex128, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(complex128)", "func(complex128, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func complex128Includes(input []complex128, e complex128, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Complex128Map(input []complex128, function interface{}) ([]complex128, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(complex128) complex128:
		r := make([]complex128, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(complex128, int) complex128:
		r := make([]complex128, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(complex128) complex128", "func(complex128, int) complex128", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func complex128Map(input []complex128, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(complex128) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(complex128, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(complex128) complex128:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(complex128, int) complex128:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(complex128) interface{}", "func(complex128, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// complex64
func complex64ForEach(input []complex64, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(complex64):
		for _, e := range input {
			fn(e)
		}

	case func(complex64, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(complex64)", "func(complex64, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func complex64Includes(input []complex64, e complex64, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Complex64Map(input []complex64, function interface{}) ([]complex64, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(complex64) complex64:
		r := make([]complex64, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(complex64, int) complex64:
		r := make([]complex64, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(complex64) complex64", "func(complex64, int) complex64", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func complex64Map(input []complex64, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(complex64) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(complex64, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(complex64) complex64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(complex64, int) complex64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(complex64) interface{}", "func(complex64, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// error
func errorForEach(input []error, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(error):
		for _, e := range input {
			fn(e)
		}

	case func(error, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(error)", "func(error, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func errorIncludes(input []error, e error, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func ErrorMap(input []error, function interface{}) ([]error, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(error) error:
		r := make([]error, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(error, int) error:
		r := make([]error, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(error) error", "func(error, int) error", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func errorMap(input []error, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(error) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(error, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(error) error:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(error, int) error:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(error) interface{}", "func(error, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// float32
func float32ForEach(input []float32, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(float32):
		for _, e := range input {
			fn(e)
		}

	case func(float32, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(float32)", "func(float32, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func float32Includes(input []float32, e float32, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Float32Map(input []float32, function interface{}) ([]float32, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(float32) float32:
		r := make([]float32, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(float32, int) float32:
		r := make([]float32, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(float32) float32", "func(float32, int) float32", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func float32Map(input []float32, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(float32) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(float32, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(float32) float32:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(float32, int) float32:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(float32) interface{}", "func(float32, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// float64
func float64ForEach(input []float64, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(float64):
		for _, e := range input {
			fn(e)
		}

	case func(float64, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(float64)", "func(float64, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func float64Includes(input []float64, e float64, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Float64Map(input []float64, function interface{}) ([]float64, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(float64) float64:
		r := make([]float64, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(float64, int) float64:
		r := make([]float64, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(float64) float64", "func(float64, int) float64", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func float64Map(input []float64, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(float64) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(float64, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(float64) float64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(float64, int) float64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(float64) interface{}", "func(float64, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// int
func intForEach(input []int, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(int):
		for _, e := range input {
			fn(e)
		}

	case func(int, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int)", "func(int, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func intIncludes(input []int, e int, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func IntMap(input []int, function interface{}) ([]int, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int) int:
		r := make([]int, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int, int) int:
		r := make([]int, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int) int", "func(int, int) int", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func intMap(input []int, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(int) int:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int, int) int:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int) interface{}", "func(int, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// int16
func int16ForEach(input []int16, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(int16):
		for _, e := range input {
			fn(e)
		}

	case func(int16, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int16)", "func(int16, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func int16Includes(input []int16, e int16, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Int16Map(input []int16, function interface{}) ([]int16, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int16) int16:
		r := make([]int16, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int16, int) int16:
		r := make([]int16, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int16) int16", "func(int16, int) int16", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func int16Map(input []int16, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int16) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int16, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(int16) int16:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int16, int) int16:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int16) interface{}", "func(int16, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// int32
func int32ForEach(input []int32, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(int32):
		for _, e := range input {
			fn(e)
		}

	case func(int32, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int32)", "func(int32, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func int32Includes(input []int32, e int32, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Int32Map(input []int32, function interface{}) ([]int32, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int32) int32:
		r := make([]int32, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int32, int) int32:
		r := make([]int32, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int32) int32", "func(int32, int) int32", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func int32Map(input []int32, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int32) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int32, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(int32) int32:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int32, int) int32:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int32) interface{}", "func(int32, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// int64
func int64ForEach(input []int64, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(int64):
		for _, e := range input {
			fn(e)
		}

	case func(int64, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int64)", "func(int64, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func int64Includes(input []int64, e int64, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Int64Map(input []int64, function interface{}) ([]int64, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int64) int64:
		r := make([]int64, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int64, int) int64:
		r := make([]int64, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int64) int64", "func(int64, int) int64", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func int64Map(input []int64, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int64) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int64, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(int64) int64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int64, int) int64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int64) interface{}", "func(int64, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// int8
func int8ForEach(input []int8, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(int8):
		for _, e := range input {
			fn(e)
		}

	case func(int8, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int8)", "func(int8, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func int8Includes(input []int8, e int8, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Int8Map(input []int8, function interface{}) ([]int8, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int8) int8:
		r := make([]int8, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int8, int) int8:
		r := make([]int8, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int8) int8", "func(int8, int) int8", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func int8Map(input []int8, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(int8) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int8, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(int8) int8:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(int8, int) int8:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(int8) interface{}", "func(int8, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// string
func stringForEach(input []string, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(string):
		for _, e := range input {
			fn(e)
		}

	case func(string, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(string)", "func(string, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func stringIncludes(input []string, e string, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func StringMap(input []string, function interface{}) ([]string, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(string) string:
		r := make([]string, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(string, int) string:
		r := make([]string, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(string) string", "func(string, int) string", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func stringMap(input []string, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(string) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(string, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(string) string:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(string, int) string:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(string) interface{}", "func(string, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// uint
func uintForEach(input []uint, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(uint):
		for _, e := range input {
			fn(e)
		}

	case func(uint, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint)", "func(uint, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func uintIncludes(input []uint, e uint, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func UintMap(input []uint, function interface{}) ([]uint, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint) uint:
		r := make([]uint, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint, int) uint:
		r := make([]uint, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint) uint", "func(uint, int) uint", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func uintMap(input []uint, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(uint) uint:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint, int) uint:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint) interface{}", "func(uint, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// uint16
func uint16ForEach(input []uint16, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(uint16):
		for _, e := range input {
			fn(e)
		}

	case func(uint16, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint16)", "func(uint16, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func uint16Includes(input []uint16, e uint16, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Uint16Map(input []uint16, function interface{}) ([]uint16, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint16) uint16:
		r := make([]uint16, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint16, int) uint16:
		r := make([]uint16, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint16) uint16", "func(uint16, int) uint16", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func uint16Map(input []uint16, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint16) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint16, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(uint16) uint16:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint16, int) uint16:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint16) interface{}", "func(uint16, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// uint32
func uint32ForEach(input []uint32, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(uint32):
		for _, e := range input {
			fn(e)
		}

	case func(uint32, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint32)", "func(uint32, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func uint32Includes(input []uint32, e uint32, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Uint32Map(input []uint32, function interface{}) ([]uint32, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint32) uint32:
		r := make([]uint32, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint32, int) uint32:
		r := make([]uint32, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint32) uint32", "func(uint32, int) uint32", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func uint32Map(input []uint32, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint32) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint32, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(uint32) uint32:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint32, int) uint32:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint32) interface{}", "func(uint32, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// uint64
func uint64ForEach(input []uint64, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(uint64):
		for _, e := range input {
			fn(e)
		}

	case func(uint64, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint64)", "func(uint64, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func uint64Includes(input []uint64, e uint64, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Uint64Map(input []uint64, function interface{}) ([]uint64, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint64) uint64:
		r := make([]uint64, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint64, int) uint64:
		r := make([]uint64, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint64) uint64", "func(uint64, int) uint64", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func uint64Map(input []uint64, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint64) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint64, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(uint64) uint64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint64, int) uint64:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint64) interface{}", "func(uint64, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// uint8
func uint8ForEach(input []uint8, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(uint8):
		for _, e := range input {
			fn(e)
		}

	case func(uint8, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint8)", "func(uint8, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func uint8Includes(input []uint8, e uint8, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func Uint8Map(input []uint8, function interface{}) ([]uint8, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint8) uint8:
		r := make([]uint8, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint8, int) uint8:
		r := make([]uint8, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint8) uint8", "func(uint8, int) uint8", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func uint8Map(input []uint8, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uint8) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint8, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(uint8) uint8:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uint8, int) uint8:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uint8) interface{}", "func(uint8, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

// uintptr
func uintptrForEach(input []uintptr, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func(uintptr):
		for _, e := range input {
			fn(e)
		}

	case func(uintptr, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uintptr)", "func(uintptr, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func uintptrIncludes(input []uintptr, e uintptr, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input)+index <= -1*len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func UintptrMap(input []uintptr, function interface{}) ([]uintptr, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uintptr) uintptr:
		r := make([]uintptr, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uintptr, int) uintptr:
		r := make([]uintptr, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uintptr) uintptr", "func(uintptr, int) uintptr", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func uintptrMap(input []uintptr, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func(uintptr) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uintptr, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func(uintptr) uintptr:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func(uintptr, int) uintptr:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func(uintptr) interface{}", "func(uintptr, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}
