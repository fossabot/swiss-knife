// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
package slice

import "fmt"

func ForEach(inputInterface interface{}, function interface{}) error {
	switch input := inputInterface.(type) {
	{{ range .Types }}
	case []{{ . }}:
		return {{ . }}ForEach(input, function)
	{{ end }}
	}

	return nil
}

func Includes(inputInterface interface{}, eInterface interface{}, indexes ...int) (bool, error) {
	switch e := eInterface.(type) {
	{{ range .Types }}
	case {{ . }}:
		input, ok := inputInterface.([]{{ . }})
		if !ok {
			e := fmt.Sprintf("%s must be from {{ . }}", inputInterface)
			return false, newError(e)
		}
		return {{ . }}Includes(input, e, indexes...), nil
	{{ end }}
	}

	return false, nil
}

func Map(inputInterface interface{}, function interface{}) ([]interface{}, error) {
	switch input := inputInterface.(type) {
	{{ range .Types }}
	case []{{ . }}:
		return {{ . }}Map(input, function)
	{{ end }}
	}

	return nil, nil
}

{{ range .Types }}
// {{ . }}
func {{ . }}ForEach(input []{{ . }}, function interface{}) error {
	if err := isFuncReturnError(function); err != nil {
		return err
	}

	switch fn := function.(type) {
	case func({{ . }}):
		for _, e := range input {
			fn(e)
		}

	case func({{ . }}, int):
		for i, e := range input {
			fn(e, i)
		}

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func({{ . }})", "func({{ . }}, int)", getFuncFirm(function))

		return newError(e)
	}

	return nil
}

func {{ . }}Includes(input []{{ . }}, e {{ . }}, indexes ...int) bool {
	index := 0

	// We only care for the first index on indexes because the lack of optional
	// parameters in Go
	if len(indexes) > 0 {
		index = indexes[0]
	}

	switch {
	case index >= len(input):
		return false
	case index < 0 && len(input) + index <= -1 * len(input):
		index = 0
	case index < 0:
		index = len(input) + index
	}

	for i := index; i < len(input); i++ {
		if input[i] == e {
			return true
		}
	}

	return false
}

func {{ Title . }}Map(input []{{ . }}, function interface{}) ([]{{ . }}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func({{ . }}) {{ . }}:
		r := make([]{{ . }}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func({{ . }}, int) {{ . }}:
		r := make([]{{ . }}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func({{ . }}) {{ . }}", "func({{ . }}, int) {{ . }}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}

func {{ . }}Map(input []{{ . }}, function interface{}) ([]interface{}, error) {
	if err := isFuncReturnError(function); err != nil {
		return nil, err
	}

	switch fn := function.(type) {
	case func({{ . }}) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func({{ . }}, int) interface{}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	case func({{ . }}) {{ . }}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e)
		}
		return r, nil

	case func({{ . }}, int) {{ . }}:
		r := make([]interface{}, len(input))
		for i, e := range input {
			r[i] = fn(e, i)
		}
		return r, nil

	default:
		e := fmt.Sprintf("function (%s) must have a firm: '%s' or '%s' and got: '%s'",
			getFuncName(function), "func({{ . }}) interface{}", "func({{ . }}, int) interface{}", getFuncFirm(function))

		return nil, newError(e)
	}

	return nil, nil
}
{{ end }}
